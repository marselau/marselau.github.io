<!DOCTYPE html>
<html lang="en-us">
  <head>
    
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.85.0 with theme Tranquilpeak 0.4.8-BETA">
<meta name="author" content="Marse Lau">
<meta name="keywords" content="低级语言">
<meta name="description" content="Hold infinity in the palm of your hand. And eternity in an hour.">


<meta property="og:description" content="Hold infinity in the palm of your hand. And eternity in an hour.">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机学科之低级语言">
<meta name="twitter:title" content="计算机学科之低级语言">
<meta property="og:url" content="https://marselau.cc/2021/02/01-engineer-04-laigh-level-lang/">
<meta property="twitter:url" content="https://marselau.cc/2021/02/01-engineer-04-laigh-level-lang/">
<meta property="og:site_name" content="ME | ZONE">
<meta property="og:description" content="Hold infinity in the palm of your hand. And eternity in an hour.">
<meta name="twitter:description" content="Hold infinity in the palm of your hand. And eternity in an hour.">
<meta property="og:locale" content="zh-cn">

  
    <meta property="article:published_time" content="2021-02-28T00:00:00">
  
  
    <meta property="article:modified_time" content="2021-02-28T00:00:00">
  
  
  
    
      <meta property="article:section" content="engineer">
    
  
  
    
      <meta property="article:tag" content="engineer">
    
  


<meta name="twitter:card" content="summary">







  <meta property="og:image" content="https://user-images.githubusercontent.com/87215174/125549614-d637556a-2e8a-45d5-adf0-a9a3e3100281.png">
  <meta property="twitter:image" content="https://user-images.githubusercontent.com/87215174/125549614-d637556a-2e8a-45d5-adf0-a9a3e3100281.png">





  <meta property="og:image" content="https://user-images.githubusercontent.com/87215174/125153235-ee026880-e184-11eb-8424-5a1e843fc25c.gif">
  <meta property="twitter:image" content="https://user-images.githubusercontent.com/87215174/125153235-ee026880-e184-11eb-8424-5a1e843fc25c.gif">


    <title>计算机学科之低级语言</title>

    <link rel="icon" href="https://user-images.githubusercontent.com/87215174/125153240-f3f84980-e184-11eb-9150-75ec295d2698.png">
    

    

    <link rel="canonical" href="https://marselau.cc/2021/02/01-engineer-04-laigh-level-lang/">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css" integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin="anonymous" />
    
    
    <link rel="stylesheet" href="https://marselau.cc/css/style-twzjdbqhmnnacqs0pwwdzcdbt8yhv8giawvjqjmyfoqnvazl0dalmnhdkvp7.min.css" />
    
    
      
        <link rel="stylesheet"  href="https://marselau.cc/css/iconfont.css">
      
    

    
      
    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="1">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://marselau.cc/">ME | ZONE</a>
  </div>
  
</header>

      <nav id="sidebar" data-behavior="1">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://marselau.cc/#about">
          <img class="sidebar-profile-picture" src="https://user-images.githubusercontent.com/87215174/125153235-ee026880-e184-11eb-8424-5a1e843fc25c.gif" alt="作者的图片" />
        </a>
        <h4 class="sidebar-profile-name">Marse Lau</h4>
        
          <h5 class="sidebar-profile-bio">The more sent my love for you, the more that I look down upon me.</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://marselau.cc/">
    
      <i class="sidebar-button-icon iconfont icon-home"></i>
      
      <span class="sidebar-button-desc">首页</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://marselau.cc/categories">
    
      <i class="sidebar-button-icon iconfont icon-categories"></i>
      
      <span class="sidebar-button-desc">分类</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://marselau.cc/tags">
    
      <i class="sidebar-button-icon iconfont icon-tags"></i>
      
      <span class="sidebar-button-desc">标签</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://marselau.cc/archives">
    
      <i class="sidebar-button-icon iconfont icon-archives"></i>
      
      <span class="sidebar-button-desc">归档</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/marselau" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon iconfont icon-about"></i>
      
      <span class="sidebar-button-desc">关于</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/marselau" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon iconfont icon-github"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://space.bilibili.com/409547673" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon iconfont icon-bilibili"></i>
      
      <span class="sidebar-button-desc">BiliBili</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://marselau.cc/index.xml">
    
      <i class="sidebar-button-icon iconfont icon-rss"></i>
      
      <span class="sidebar-button-desc">RSS</span>
    </a>
  </li>


    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="1"
        class="
               hasCoverMetaIn
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title" itemprop="headline">
      计算机学科之低级语言
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2021-02-28T00:00:00Z">
        
  
  
  
  
    2021年02月28日
  

      </time>
    
    
  
  
    <span>发布在</span>
    
      <a class="category-link" href="https://marselau.cc/categories/engineer">engineer</a>
    
  

  </div>

</div>
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              <p>Hold infinity in the palm of your hand. And eternity in an hour.</p>
<h2 id="目录catalog">目录（Catalog）</h2>
<ul>
<li>计算操作</li>
<li>机器语言
<ul>
<li>Pep/8：一台虚拟机</li>
<li>Pep/8 指令格式</li>
<li>Pep/8 示例指令</li>
</ul>
</li>
<li>程序实例
<ul>
<li>Pep/8 手工模拟</li>
</ul>
</li>
<li>汇编语言
<ul>
<li>Pep/8 汇编语言</li>
<li>Hello 程序的汇编语言版本</li>
<li>一个新的 Pep/8 汇编程序</li>
</ul>
</li>
<li>表达算法
<ul>
<li>伪代码的功能</li>
</ul>
</li>
<li>程序测试</li>
</ul>
<h2 id="计算操作">计算操作</h2>
<p>我们所用的程序设计语言都必须反映出计算机能够执行的操作类型。计算机是能够存储、检索和处理数据的可编程电子设备。这个定义中的操作字包括可编程、存储、检索和处理。</p>
<p>数据和操作数据的指令逻辑上是相同的，它们存储在相同的地方，这就是「可编程」这一词的意义所在。操作数据的指令和数据一起存储在机器中，要改变计算机对数据的处理，只需改变指令即可。</p>
<p>存储、检索和处理是计算机能够对数据执行的动作，也就是说，控制单元执行的指令能够把数据存储到机器的内存中，在机器内存中检索数据，在算术逻辑单元中以某种方式处理数据。词语「处理」非常通用，在机器层，处理涉及在数据值上执行算术运算或逻辑操作。</p>
<p>那么，存储在计算机内存中的数据来自何处呢？人们究竟如何查看内存中存储的是什么？规定输入设备与 CPU 之间以及 CPU 与输出设备之间的交互的是另外一些指令。</p>
<h2 id="机器语言">机器语言</h2>
<p>计算机真正执行的程序设计指令是用机器语言编写的指令，这些指令固定在计算机的硬件中。</p>
<p>起初，人们只能用机器语言来编写需要执行的指令（程序），因为最初还没有发明程序设计语言，所以只能用这种原始的方式编程。那么，计算机指令是如何表示的呢？每种处理器都有自己专用的机器指令集合，这些指令是处理器真正能够执行的。由于这个指令集的数量有限，所以处理器的设计者就可以列出所有的指令，然后分配一个二进制代码来表示它们（这就跟字符集的概念类似）。</p>
<p>处理器与它能够执行的指令之间关系非常和谐，它本来就是能够识别专用命令的二进制表示，因此，计算机必需参考的命令的真实清单并不存在，而是在设计时就实际嵌入到 CPU 中了。</p>
<p>每条机器语言指令都只能执行一个非常低级的任务。在机器语言中，处理过程的每一个微小的步骤都必须被明确地编码。即使是求两个整数之和这样的小任务，也需要三条指令才能完成：首先将一个数字传递到累加器中，然后再将另一个数字传递到累加器中，最后将得到的计算结果保存。</p>
<p>使用机器语言编程的程序设计员，必需记忆每种二进制代码对应的指令，他们必须对数字尤为敏感，而且要求非常仔细。第一代程序员都是数学家、科学家和工程师，能做到这点丝毫不令人怀疑。</p>
<p>但是，并非只有数学家们才能使用机器语言编程，事实上，目前几乎没有程序是用机器语言写就的。主要是因为编写机器语言程序太费时间，你也不想花上半辈子时间去给程序排错吧。</p>
<p>现如今大多数的程序都是使用高级语言编写的，再次也是使用汇编语言，而绝对没有人会无聊到使用机器语言。虽然使用高级语言或汇编语言编写的程序，最终都会被翻译成机器语言指令执行。</p>
<h3 id="pep8一台虚拟机">Pep/8：一台虚拟机</h3>
<p>根据定义，机器代码因机器的不同而不同。回想一下，就像每扇门上的锁都必须由对应的钥匙打开一样，每种机器也同样只能由对应的指令集操作，而这个指令集我们叫做机器语言或机器代码、机器语言指令，无论是什么，它表示的是 CPU 能够执行的所有指令的集合。</p>
<p>每种机器都有其独立的机器语言，这里因为要展示一个机器语言程序，为了统一，我们通过使用一个虚拟机来解决这一问题。在这种情况下，是为了包含我们想要展示的真实电脑所具备的重要特性而设计的计算机。在这里，我们使用由斯坦利•沃福德设计的虚拟计算机 Pep/8。</p>
<p>Pep/8 中内置有 39 个机器语言指令，当然了，在这里我们不是要记忆这 39 个指令，仅仅作为了解。</p>
<p>Pep/8 的内存单元由 65536 字节的存储空间构成，从 0 到 65535 进行编号。每个字节由 8 位二进制数字组成，我们通常用 2 位十六进制数字来表示一个字中的位模式。Pep/8 的字长是 2 字节或 16 比特，这样，向算术逻辑单元流入的数据或从其流出的数据在长度上就是 16 比特。</p>
<p>寄存器是中央处理器算术逻辑单元中的一小块存储区域，它用来存储特殊的数据和中间值。Pep/8 有七个寄存器，因为作为了解我们用不到全部，所以重点研究其中的三个：</p>
<ul>
<li>程序计数器（PC），其中包含下一条将要被执行的指令的地址。</li>
<li>指令寄存器（IR），其中包含了正在被执行的指令的一个副本。</li>
<li>累加器（一种特殊的寄存器），用来保存要操作的数据和结果。</li>
</ul>
<p>一个字节能够表示的最大十进制数字是 255，用二进制表示是 1111 1111，用十六进制表示是 FF。一个字（16 位）能表示的最大十进制数字是 65535，二进制是 1111 1111 1111 1111，十六进制是 FFFF。如果既要表示正数，又要表示负数，那么在量级上就要少一位（用作符号位），因此可以表示的数值是 -32767 到 +32767，十六进制是 -7FFF 到 +7FFF。</p>
<p>当我们使用 Pep/8 时，了解上述几点是非常重要的，可用的比特数决定了我们可以使用的内存大小。</p>
<h3 id="pep8-指令格式">Pep/8 指令格式</h3>
<p>我们说过，指令要先进入指令寄存器，然后经过译解，最后被执行。所以，我们先来分析一下 Pep/8 中的指令格式，其由两部分组成，即 8 位的指令说明符和 16 位的操作数说明符。</p>
<ul>
<li>指令说明符（指令的第一个字节）说明了要执行什么操作（如把一个数加到一个已经存储到寄存器中的值上）和如何解释操作数的位置。</li>
<li>操作数说明符（指令的第二和第三字节）存放的是操作数本身或者操作数的地址。</li>
</ul>
<p>指令说明符的格式根据表示一个具体操作所用的比特数的不同而不同。在 Pep/8 中，操作代码（称为操作码）的长度从 4 比特到 8 比特不等。我们在这里所用的操作码长度是 4 比特或 5 比特。4 比特操作码的第 5 位用来指定使用哪个寄存器。</p>
<p>寄存器 A（累加器）的寄存器说明符是 0（这是唯一一个我们将用到的寄存器）。</p>
<p>3 比特的寻址模式说明符标识了怎样解析指令中的操作数部分。</p>
<p>如果寻址模式是 000，那么指令的操作数说明符中存储的就是操作数，这种寻址模式称为立即寻址。如果寻址模式是 001，那么操作数说明符中存储的就是操作数所在的内存地址名称，这是直接寻址。</p>
<p>立即寻址模式和直接寻址模式之间的差别十分重要，因为它决定了操作中涉及的数据存储或将要被存储的位置。没有操作数（要处理的数据）的指令称为一元指令，这些指令没有操作数说明符。也就是说，一元指令的长度是 1 个字节，而不是 3 个字节，典型如停止指令。</p>
<h3 id="pep8-示例指令">Pep/8 示例指令</h3>
<p>让我们来看一些 Pep/8 中具体的指令，然后将它们放到一起写一段 Hello 程序。下表包含了我们将要讲解的操作的 4 比特操作代码：</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作码</th>
<th style="text-align:left">指令含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0000</td>
<td style="text-align:left">停止执行</td>
</tr>
<tr>
<td style="text-align:left">1100</td>
<td style="text-align:left">将操作数载入寄存器 A 中</td>
</tr>
<tr>
<td style="text-align:left">1110</td>
<td style="text-align:left">将寄存器 A 的内容存储到操作数中</td>
</tr>
<tr>
<td style="text-align:left">0111</td>
<td style="text-align:left">将操作数加到寄存器 A 中</td>
</tr>
<tr>
<td style="text-align:left">1000</td>
<td style="text-align:left">在寄存器 A 的值中减去操作数的值</td>
</tr>
<tr>
<td style="text-align:left">01001</td>
<td style="text-align:left">把字符输入操作数</td>
</tr>
<tr>
<td style="text-align:left">01010</td>
<td style="text-align:left">从操作数输出字符</td>
</tr>
</tbody>
</table>
<h4 id="0000-停止执行">0000 停止执行</h4>
<p>在读取 - 执行周期中，当操作代码全部为零时，程序将终结。停止指令是一个一元指令，所以它只占用一个字节，这一字节中的最右三位被忽略了。</p>
<h4 id="1100-将操作数载入寄存器-a-中">1100 将操作数载入寄存器 A 中</h4>
<p>这一指令将一个字（两字节）载入寄存器 A 中。模式说明符说明了要载入该字的位置，这样载入操作码就因寻址模式说明符的不同而有了不同含义。模式说明符确定了指令的操作数部分（在指令的第二和第三字节）所存储的就是将要载入的值，或是将要载入的值的地址。</p>
<table>
<thead>
<tr>
<th style="text-align:left">下面是一条三字节指令</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">指令说明符</td>
<td style="text-align:left">1100 0000</td>
</tr>
<tr>
<td style="text-align:left">操作数说明符</td>
<td style="text-align:left">0000 0000 0000 0111</td>
</tr>
</tbody>
</table>
<p>寻址模式是立即寻址，即要被载入寄存器 A 中的值在操作数说明符中。在这一指令执行之后，指令的第二和第三字节的内容（操作数说明符）将被载入寄存器 A（累加器）中。</p>
<table>
<thead>
<tr>
<th style="text-align:left">下面是另一条载入指令</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">指令说明符</td>
<td style="text-align:left">1100 0001</td>
</tr>
<tr>
<td style="text-align:left">操作数说明符</td>
<td style="text-align:left">0000 0000 0001 1111</td>
</tr>
</tbody>
</table>
<p>寻址模式是直接寻址，意味着操作数本身并不在操作数说明符中（指令的第二和第三字节），而是操作数说明符存储了操作数驻留在内存中的地址。因此，当这一指令被执行时，存储单元 001F 中存储的内容将被载入到寄存器 A 中。</p>
<p>寄存器 A 存储了一个字长（两字节），这样，像这种情况中当一个地址用来指定一个字（而不是一个单独的字节）时，这一字的最左边的一字节就是给定的地址。因此相邻位置 001F 和 0020 中的内容被载入寄存器 A 中。操作数的内容并未改变。</p>
<h4 id="1110-将寄存器-a-的内容存储到操作数中">1110 将寄存器 A 的内容存储到操作数中</h4>
<p>这条指令将把寄存器 A 中的内容存储到操作数中指定的位置，既可以是操作数本身，也可以是地址。</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">指令说明符</td>
<td style="text-align:left">1110 0000</td>
</tr>
<tr>
<td style="text-align:left">操作数说明符</td>
<td style="text-align:left">0000 0000 0000 0111</td>
</tr>
</tbody>
</table>
<p>这一指令将寄存器 A 的内容存储到从位置 000A 开始的字中。在存储操作码中使用立即寻址模式是非法的，也就是说，我们不能尝试将寄存器的内容存储到操作数说明符中。</p>
<h4 id="0111-将操作数加到寄存器-a-中">0111 将操作数加到寄存器 A 中</h4>
<p>与载入操作类似，相加操作也使用寻址模式说明符，但是它有两种解释方式：</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">指令说明符</td>
<td style="text-align:left">0111 0000</td>
</tr>
<tr>
<td style="text-align:left">操作数说明符</td>
<td style="text-align:left">0000 0010 0000 1010</td>
</tr>
</tbody>
</table>
<p>指令的第二和第三个字节的内容（操作数说明符）被加到寄存器 A 的内容之中（十六进制数 20A）。</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">指令说明符</td>
<td style="text-align:left">0111 0001</td>
</tr>
<tr>
<td style="text-align:left">操作数说明符</td>
<td style="text-align:left">0000 0010 0000 1010</td>
</tr>
</tbody>
</table>
<p>寻址模式说明符说明寻址方式是直接寻址，指令的第二和第三字节的内容说明操作数位置（020A），该位置上的内容被加到寄存器 A 中。</p>
<h4 id="1000-在寄存器-a-的值中减去操作数的值">1000 在寄存器 A 的值中减去操作数的值</h4>
<p>这一指令与加法操作类似，只是它是从寄存器 A 中减去操作数而不是相加。与载入和相加操作一样，指令根据寻址模式的不同而有不同的形式。</p>
<h4 id="01001-把字符输入操作数">01001 把字符输入操作数</h4>
<p>这一指令允许程序在运行的时候从输入设备中读取 ASCII 码形式的字符。由于这条指令只能使用直接寻址，所以输入的字符被存储在操作数说明符显示的地址中。</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">指令说明符</td>
<td style="text-align:left">0100 1001</td>
</tr>
<tr>
<td style="text-align:left">操作数说明符</td>
<td style="text-align:left">0000 0000 0000 1010</td>
</tr>
</tbody>
</table>
<p>这一指令从输入设备中读取一个 ASCII 码字符并将它存储到内存单元 000A 中。</p>
<h4 id="01010-从操作数输出字符">01010 从操作数输出字符</h4>
<p>这一指令在程序运行时将一个 ASCII 码字符发送到输出设备中，寻址模式是立即寻址或是直接寻址。</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">指令说明符</td>
<td style="text-align:left">0101 0000</td>
</tr>
<tr>
<td style="text-align:left">操作数说明符</td>
<td style="text-align:left">0000 0000 0100 0001</td>
</tr>
</tbody>
</table>
<p>由于声明了寻址模式为立即寻址，这一指令将操作数说明符中存储的 ASCII 码字符取出。操作数说明符中的值是 1000 0001，是十六进制的 41、十进制的 65，对应于 ASCII 码字符集中的 A。因此，字母 A 将被显示到屏幕上。</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">指令说明符</td>
<td style="text-align:left">0101 0001</td>
</tr>
<tr>
<td style="text-align:left">操作数说明符</td>
<td style="text-align:left">0000 0000 0000 1010</td>
</tr>
</tbody>
</table>
<p>由于使用的是直接寻址模式，这一指令输出的是存储在操作数说明符中的地址（000A）的 ASCII 码字符，与在这一地址上的值相对应的 ASCII 码字符将被输出。</p>
<h2 id="程序实例">程序实例</h2>
<p>现在，我们已经准备好编写我们的第一个机器语言程序：在屏幕上显示 Hello。这个程序一共有 6 条指令：5 条用于显示字符，1 条用于指示过程的结束。</p>
<p>在屏幕上显示字符的指令是 0101，即从操作数输出字符的操作。那么应该把字符存储在内存中，使用直接寻址模式输出它们呢，还是应该把字符存储在操作数说明符中使用立即寻址模式呢？在这里，我们使用的是立即寻址模式。寻址模式说明符是 000，ASCII 码将存放在指令的第三个字节中。</p>
<table>
<thead>
<tr>
<th style="text-align:left">行为</th>
<th style="text-align:left">二进制指令</th>
<th style="text-align:left">十六进制指令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Write &lsquo;H&rsquo;</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">指令说明符</td>
<td style="text-align:left">0101 0000</td>
<td style="text-align:left">50</td>
</tr>
<tr>
<td style="text-align:left">操作数说明符</td>
<td style="text-align:left">0000 0000 0100 1000</td>
<td style="text-align:left">0048</td>
</tr>
<tr>
<td style="text-align:left">Write &lsquo;e&rsquo;</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">指令说明符</td>
<td style="text-align:left">0101 0000</td>
<td style="text-align:left">50</td>
</tr>
<tr>
<td style="text-align:left">操作数说明符</td>
<td style="text-align:left">0000 0000 0110 0101</td>
<td style="text-align:left">0065</td>
</tr>
<tr>
<td style="text-align:left">Write &lsquo;l&rsquo;</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">指令说明符</td>
<td style="text-align:left">0101 0000</td>
<td style="text-align:left">50</td>
</tr>
<tr>
<td style="text-align:left">操作数说明符</td>
<td style="text-align:left">0000 0000 0110 1100</td>
<td style="text-align:left">006C</td>
</tr>
<tr>
<td style="text-align:left">Write &lsquo;l&rsquo;</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">指令说明符</td>
<td style="text-align:left">0101 0000</td>
<td style="text-align:left">50</td>
</tr>
<tr>
<td style="text-align:left">操作数说明符</td>
<td style="text-align:left">0000 0000 0110 1100</td>
<td style="text-align:left">006C</td>
</tr>
<tr>
<td style="text-align:left">Write &lsquo;o&rsquo;</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">指令说明符</td>
<td style="text-align:left">0101 0000</td>
<td style="text-align:left">50</td>
</tr>
<tr>
<td style="text-align:left">操作数说明符</td>
<td style="text-align:left">0000 0000 0110 1111</td>
<td style="text-align:left">006F</td>
</tr>
<tr>
<td style="text-align:left">Stop</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">指令说明符</td>
<td style="text-align:left">0000 0000</td>
<td style="text-align:left">00</td>
</tr>
</tbody>
</table>
<p>第二列展示的是用二进制表示的机器语言程序，第三列展示的是用十六进制表示的程序。我们必须用二进制构造操作数说明符，因为它由 4 位操作码、1 位寄存器说明符和 3 位寻址模式说明符构成。</p>
<p>我们使用双引号来指一组字符，如 &ldquo;Hello&rdquo;，使用单引号来指单个字符。这是编程语言中的惯例。</p>
<h3 id="pep8-手工模拟">Pep/8 手工模拟</h3>
<p>让我们通过执行读取 - 执行周期的步骤来模拟这个程序的运行。这种手动跟踪的方式绝对能让你理解计算机程序运行的步骤。首先，回忆一下读取 - 执行周期的四个步骤：</p>
<ol>
<li>从程序计数器指定的位置读取下一条指令。</li>
<li>译解指令（并且更新程序计数器）。</li>
<li>如果需要，获取数据（操作数）。</li>
<li>执行指令。</li>
</ol>
<p>在我们的程序中有 6 条指令，假设它们存放在连续的内存单元中，第一条指令存储在地址为 0000 ~ 0002 的存储单元中。所以第一步是把 0000 载入程序计数器。我们将分析执行过程中每个阶段内的程序计数器和指令寄存器。由于这个过程不访问寄存器 A（累加器），所以这里不必费心去表示它。</p>
<p>在第一个读取操作结束时，程序计数器和指令寄存器如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">程序计数器</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:left">指令寄存器</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<p>这条指令将被译解为用立即寻址模式进行字符输出的指令。因为这条指令有三个字节，所以程序计数器将加 3。从存储在指令寄存器中的操作数说明符获得数据，该指令被执行，字母 &lsquo;H&rsquo; 输出到屏幕。</p>
<p>第二个读取操作执行后，程序计数器和指令寄存器如下所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">程序计数器</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:left">指令寄存器</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>这条指令将被译解为另一个用立即寻址模式进行字符输出的指令。这条指令有三个字节，所以程序计数器再次加 3。数据被找到，随后执行指令，字母 &lsquo;e&rsquo; 输出到屏幕。</p>
<p>执行随后三条指令的方式，与前两条完全相同，所以不再赘述。最后，当字母 &lsquo;o&rsquo; 输出到屏幕后：</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">程序计数器</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:left">指令寄存器</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>这条指令被译解为停止指令，所以寻址模式和操作数说明符的内容被忽略，该读取 - 执行周期停止。</p>
<h2 id="汇编语言">汇编语言</h2>
<p>前面提到过，开发的第一种辅助程序员进行程序设计的工具就是汇编语言。汇编语言给每条机器语言指令分配了一个助记指令码，程序员可以用这些助记码代替二进制数字。</p>
<p>因为在计算机上执行的每个程序最终都要被翻译成机器语言的形式，所以一个名为「汇编器」的程序将读取每条指令的助记码，然后把它翻译成等价的机器语言。因为每种类型的计算机都有自己的机器语言，所以有多少种机器，就有多少种汇编语言和翻译程序。</p>
<h3 id="pep8-汇编语言">Pep/8 汇编语言</h3>
<p>这里我们将介绍一些基于 Pep/8 虚拟机指令集的汇编代码，目的是让你了解使用汇编语言进行程序设计比使用机器代码的优势在哪里。在 Pep/8 汇编语言中，每个寄存器都有一个操作码，操作数是十六进制的，寻址模式说明符由字母 i 或 d 指明。</p>
<table>
<thead>
<tr>
<th style="text-align:left">助记码</th>
<th style="text-align:center">操作数，寻址模式说明符</th>
<th style="text-align:left">指令的含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">STOP</td>
<td style="text-align:center"></td>
<td style="text-align:left">停止执行</td>
</tr>
<tr>
<td style="text-align:left">LDA</td>
<td style="text-align:center">0x008B,i</td>
<td style="text-align:left">把 008B 载入寄存器 A</td>
</tr>
<tr>
<td style="text-align:left">LDA</td>
<td style="text-align:center">0x008B,d</td>
<td style="text-align:left">把内存单元 8B 中的内容载入寄存器 A</td>
</tr>
<tr>
<td style="text-align:left">STA</td>
<td style="text-align:center">0x008B,d</td>
<td style="text-align:left">把寄存器 A 中的内容存入内存单元 8B</td>
</tr>
<tr>
<td style="text-align:left">ADDA</td>
<td style="text-align:center">0x008B,i</td>
<td style="text-align:left">把 008B 加到寄存器 A 中</td>
</tr>
<tr>
<td style="text-align:left">ADDA</td>
<td style="text-align:center">0x008B,d</td>
<td style="text-align:left">把内存单元 8B 中的内容加到寄存器 A 中</td>
</tr>
<tr>
<td style="text-align:left">SUBA</td>
<td style="text-align:center">0x008B,i</td>
<td style="text-align:left">从寄存器 A 中减去 008B</td>
</tr>
<tr>
<td style="text-align:left">SUBA</td>
<td style="text-align:center">0x008B,d</td>
<td style="text-align:left">从寄存器 A 中减去内存单元 8B 中的内容</td>
</tr>
<tr>
<td style="text-align:left">BR</td>
<td style="text-align:center"></td>
<td style="text-align:left">分支到操作数说明符中指定的位置</td>
</tr>
<tr>
<td style="text-align:left">CHARI</td>
<td style="text-align:center">0x008B,d</td>
<td style="text-align:left">读取一个字符，把它存如内存单元 8B 中</td>
</tr>
<tr>
<td style="text-align:left">CHARO</td>
<td style="text-align:center">0x008B,i</td>
<td style="text-align:left">输出字符 B</td>
</tr>
<tr>
<td style="text-align:left">CHARO</td>
<td style="text-align:center">0x008B,d</td>
<td style="text-align:left">输出存储在内存单元 8B 中的字符</td>
</tr>
<tr>
<td style="text-align:left">DECI</td>
<td style="text-align:center">0x008B,d</td>
<td style="text-align:left">读取一个十进制数字，把它存储在内存单元 8B 中</td>
</tr>
<tr>
<td style="text-align:left">DECO</td>
<td style="text-align:center">0x008B,i</td>
<td style="text-align:left">输出十进制数值 139（也就是十六进制的 8B）</td>
</tr>
<tr>
<td style="text-align:left">DECO</td>
<td style="text-align:center">0x008B,d</td>
<td style="text-align:left">输出存储在内存单元 8B 中的十进制数值</td>
</tr>
</tbody>
</table>
<p>你想知道为什么我们在机器语言中没做任何运算吗？那是因为输出只能定义为字符。如果我们进行算术运算，我们将不得不将数字转换为字符的形式，这比我们期望的更复杂。</p>
<p>Pep/8 汇编语言中提供了助记码 DECI 和 DECO，它允许我们做十进制数字的输入和输出，这个说法有点误导，因为实际上它们还涉及后台调用的一系列命令。</p>
<p>在机器语言程序中，每条指令都要先存储到内存中，然后才能执行。从汇编语言开始，大多数程序设计语言都有两种类型的指令，即要翻译的指令和翻译程序所用的指令。</p>
<p>下面是 Pep/8 汇编器中的几条有用的汇编器指令，这些汇编器指令也叫做伪操作。</p>
<table>
<thead>
<tr>
<th style="text-align:left">伪操作</th>
<th style="text-align:left">参数</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">.ASCII</td>
<td style="text-align:left">&ldquo;Str\x00&rdquo;</td>
<td style="text-align:left">表示一个 ASCII 字节的字符串</td>
</tr>
<tr>
<td style="text-align:left">.BLOCK</td>
<td style="text-align:left">字节数</td>
<td style="text-align:left">创建一个字节块</td>
</tr>
<tr>
<td style="text-align:left">.WORD</td>
<td style="text-align:left">值</td>
<td style="text-align:left">创建一个字，并存值进去</td>
</tr>
<tr>
<td style="text-align:left">.END</td>
<td style="text-align:left"></td>
<td style="text-align:left">表示汇编语言程序执行的终点</td>
</tr>
</tbody>
</table>
<h3 id="hello-程序的汇编语言版本">Hello 程序的汇编语言版本</h3>
<p>让我们看看汇编语言版本的在屏幕上显示 &ldquo;Hello&rdquo; 的程序。Pep/8 汇编语言允许我们直接指定字符输出，还允许我们在指令旁边添加注释。</p>
<p>注释是为程序使用者而写的说明性文字，解释了会发生什么情况。无论编写什么程序，注释都是一个重要组成部分。Pep/8 汇编器会忽略从 ; 开始到一行结束的所有字符，这就是一个注释。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">CHARO 0x0048,i  ; Output an &#39;H&#39;
CHARO 0x0065,i  ; Output an &#39;e&#39;
CHARO 0x006C,i  ; Output an &#39;l&#39;
CHARO 0x006C,i  ; Output an &#39;l&#39;
CHARO 0x006F,i  ; Output an &#39;o&#39;
STOP
.END
</code></pre></div><p>汇编器的输入是一个用汇编语言编写的程序，输出是用机器代码编写的程序。汇编语言是编程语言的发展历史中的重要一步，它通过将指令抽象成助记符（单词或单词缩写），从而隐藏了机器语言编程的诸多细节。虽然在执行时增加了一个步骤（即翻译汇编语言程序），但是这个额外的步骤是非常值得的，这大大简化了程序员的工作，从而有更充足的时间去编写真正解决实际问题的软件程序。</p>
<h3 id="一个新-pep8-汇编程序">一个新 Pep/8 汇编程序</h3>
<p>让我们编写一个稍微复杂点的程序：读入三个数字，然后输出它们的和。</p>
<p>我们如何手动完成这个任务呢？如果有一个计算器，首先肯定是把总值清零，也就是把和设为 0；然后输入第一个数字，把它加到总值上，保存此次计算结果；接着输入第二个数字，把它加到总值上，再保存；最后输入第三个数字，把它加到总值上，得到最终结果。我们可以根据这种算法对程序建模。</p>
<p>复杂的是，我们必须把这里的四个标识符与内存单元关联起来。如果把数据放在程序的最后，就要求我们知道程序自身占用多少个内存单元。</p>
<p>因此，我们可以把数据放到程序开头，从而简化这个过程。</p>
<p>我们把标识符关联到 0001 开始的内存单元，让读取 - 执行周期在运行程序时跳过这些内存单元。实际上，可以给内存单元分配标识符，然后在程序中使用这些名字即可。我们用伪操作 .WORD 为总值创建空间，这样就可以把和设置为 0，然后用 .BLOCK 为三个数字创建空间：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">       BR    main    ; Branch around data
sum:  .WORD  0x0000  ; Set up word with zero
num1: .BLOCK 2       ; Set up a two byte block for num1
num2: .BLOCK 2       ; Set up a two byte block for num2
num3: .BLOCK 2       ; Set up a two byte block for num3

main: LDA    sum,d   ; Load zero into the accumulator
      DECI   num1,d  ; Read and store num1
      ADDA   num1,d  ; Add num1 to the accumulator
      DECI   num2,d  ; Read and store num2
      ADDA   num2,d  ; Add num2 to the accumulator
      DECI   num3,d  ; Read and store num3
      ADDA   num3,d  ; Add num3 to the accumulator
      STA    sum,d   ; Store accumulator into sum
      DECO   sum,d   ; Output sum
      STOP           ; Stop the processing
      .END           ; End of the program
</code></pre></div><h4 id="添加名为分支的控制流程">添加名为分支的控制流程</h4>
<p>已经表明，一个程序计数器设为下一条被执行的指令地址的 BR 指令可以改变程序计数器。是否有其他的方式来改变程序的执行流程？我们可以问一个问题并在答案的基础上采取一定行动吗？</p>
<p>当然，下面是两个有用的操作码及其含义：</p>
<table>
<thead>
<tr>
<th style="text-align:left">助记码</th>
<th style="text-align:left">操作数，寻址模式说明符</th>
<th style="text-align:left">指令的含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">BRLT</td>
<td style="text-align:left">i</td>
<td style="text-align:left">如果寄存器 A 是负数，则将 PC 设置为操作数</td>
</tr>
<tr>
<td style="text-align:left">BREQ</td>
<td style="text-align:left">i</td>
<td style="text-align:left">如果寄存器 A 为零，则将 PC 设置为操作数</td>
</tr>
</tbody>
</table>
<p>举个例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">LDA  num1,d    ; Load num1 into A register
BRLT lessThan  ; Branch to lessThan if num1 less than 0
</code></pre></div><p>在把 num1 载入累加器时，如果它的值是负数，则把 PC 设置为 lessThan 的内存地址，否则不变。让我们更改一下前面的程序：如果三个数的和是正数，则输出和，否则，就输出错误消息。</p>
<p>在哪里进行测试呢？就在要把计算出的结果存入地址 sum 之前，测试寄存器 A，小于零就输出 &lsquo;E&rsquo;。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">         BR    main     ; Branch around data
sum:    .WORD  0x0000   ; Set up word with zero
num1:   .BLOCK 2        ; Set up a two byte block for num1
num2:   .BLOCK 2        ; Set up a two byte block for num2
num3:   .BLOCK 2        ; Set up a two byte block for num3

negMsg: CHARO  0x0045,i ; Print &#39;E&#39;
        BR     finish   ; Branch to STOP instruction

main:   LDA    sum,d    ; Load zero into the accumulator
        DECI   num1,d   ; Read and store num1
        ADDA   num1,d   ; Add num1 to the accumulator
        DECI   num2,d
        ADDA   num2,d
        DECI   num3,d
        ADDA   num3,d
        BRLT   negMsg   ; Branch to negMsg if A &lt; 0
        STA    sum,d    ; Store result into sum
        DECO   sum,d    ; Output sum

finish: STOP
        .END
</code></pre></div><p>可以用 BRLT 指令测试和是否为负数。如果寄存器 A 是负数，那么 PC 的内容就将被 BRLT 后面的操作数代替，使下一条指令从操作数指定的内存单元开始。必须给这条指令一个名字，在这里我们称之为 negMsg。当显示出错误消息后，必须跳转到让程序结束的 STOP 行，也就是说，必须给这个代码行一个名字，这里称为 finish。</p>
<h4 id="添加名为循环的控制流程">添加名为循环的控制流程</h4>
<p>如果我们想读入求和的数字是 4 个怎么办？5 个呢？任意数量呢？</p>
<p>实际上，我们可以想输入多少个值求和就输入多少个值，只要给程序添加计数循环代码，就可以重复指定次数的读值操作并累加计算出结果（和）。</p>
<p>那么又如何知道已经读入了多少个值呢？可以在每次重复循环时建立一个散列标记，之后比较散列标记的和与我们希望循环的次数。实际上，这个散列标记就是在内存中一个为 0 的存储单元，我们称之为计数器（counter）。每次循环都给这个计数器加 1，这样当计数器的值等于我们想输入数字的数量时，就完成了对所有值的读取与计数。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">          BR    main     ; Branch around data
sum:     .WORD  0x0000   ; Set up word with zero
num:     .BLOCK 2        ; Set up a two byte block for num
limit:   .BLOCK 2        ; Set up a two byte block for limit
counter: .WORD 0x0000    ; Set up counter with zero

main:    DECI limit,d    ; Input limit

loop:    DECI num,d      ; Read and sum limit numbers
         LDA  num,d
         ADDA sum,d
         STA  sum,d
         LDA  counter,d  ; Load counter into A register
         ADDA 1,i        ; Add 1 to counter
         STA  counter,d
         CPA  limit,d    ; Compare counter and limit
         BREQ quit       ; Go to quit if equal
         BR   loop       ; Repeat loop

quit:    DECO sum,d      ; Output sum
         STOP
         .END
</code></pre></div><h2 id="表达算法">表达算法</h2>
<p>在前面的部分，我们已经写了输出问候语、读取三个数字并求和、如果和为负数就打印错误消息、读取任意数字并求和。我们先是以文字的形式描述每个问题的解决方案，然后再写代码。</p>
<p>在计算领域，解决问题的方案就称为算法。正如你前面所看到的，将一段文字叙述转化成代码，并不总是一个明确的过程。伪代码也是一种语言，它可以让我们以更清晰的形式表达算法。</p>
<h3 id="伪代码的功能">伪代码的功能</h3>
<p>在前面我们讲过，语言层包围着真正的机器。当时并未提及伪代码，因为它不是一种程序设计语言，而更像一种人们用来说明带有明显逻辑性操作的便携语言。虽然伪代码没有特定的语法规则，但在说明中必须清晰表达出下面的概念。</p>
<h4 id="变量赋值">变量赋值</h4>
<p>变量是出现在伪代码算法中的名字，引用的是内存中存储值的位置。这些名字要能反映出它存放的值在算法中的角色。如果有了变量，就要有把值放入变量的方法，我们称为赋值语句：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">Set sum to 0
</code></pre></div><p>这个语句将数值（0）在内存单元的地址指向变量 sum。在程序其他地方使用 sum 实际就是该值。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">Set sum to sum + num
</code></pre></div><p>这个语句将指向 sum 的值与指向 num 的值相加，结果又指向 sum。</p>
<p>所以，指向变量的可以是单个值的地址，也可以是由变量和操作符构成的表达式（最终其实是值）。</p>
<h4 id="输入输出">输入输出</h4>
<p>大多数计算机程序只处理某种类型的数据，所以必须能够从外部世界获取数据（输入），然后把处理结果输出到屏幕上。我们可以使用单词 Write 来表示输出，使用 Read 来代表输入操作。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">Set sum to 0

Write &#34;Enter the number of values to read and sum&#34;
Read num

Set sum to sum + num
Write sum
</code></pre></div><p>双引号之间的所有字符组成一串，称为字符串，它们告诉用户要输入什么或输出什么。</p>
<p>另外，是使用 Write 还是 Print 来进行输出，是使用 Get、Input 还是 Read 来获取输入，并不重要，自己喜欢用哪个就用哪个。不过记住一点，伪代码是写给人看的，为的是方便把它们转化成代码，所以，在书写伪代码时，保持一个统一的标准是非常有必要的。</p>
<h4 id="选择结构">选择结构</h4>
<p>用选择结构可以依据条件判断的结果选择执行或跳过某项操作。选择结构中，使用小括号包裹判定条件。例如，下面的伪代码将判断到底是输出计算机结果或错误消息：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">// Read and sum three numbers
IF (sum &lt; 0)
  Print errMsg
ELSE
  Print sum
// Stop or whatever comes next
</code></pre></div><p>这里，我们使用缩进来给不同的语句块分组，控制将返回到没有缩进的语句。符号 // 用于添加注释，算是大部分编程语言的一个惯例，表示它们不是算法的一部分。</p>
<p>上述伪代码中的选择结构，使用的叫做 if-then-else 版本，这是在两项操作中进行选择。如果（if）条件符合，就（then）执行一系列语句，否则（else）就执行另一些语句。</p>
<p>此外，还有一个 if-else 的版本。如果（if）条件符合，就执行一系列语句，否则（else）就跳过。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">IF (sum &lt; 0)
  Print errMsg

Print sum
</code></pre></div><p>上述代码只在 sum 小于 0 时输出错误消息，否则就跳过这块代码。下一行是输出 sum 的结果，不做任何判断，也就是说，无论 sum 的结果是正数或负数，都会将其输出。只不过在 sum 小于 0 的时，会在输出结果之前输出一段错误消息。</p>
<h4 id="循环结构">循环结构</h4>
<p>循环，也可叫做重复，指在条件满足的前提下，重复执行某一块代码。比如，在求和问题中，计数器将被初始化、检验并增加。例如，下面的例子，将首先读入想要输入的数字数量，然后通过判断计数器与预期数量的数字，重复获取要进行求和的数字：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">Set sum to 0

Write &#34;Enter the numbers that you want to sum&#34;
Set limit to numbers

Write &#34;Enter the numbers that you will sum to&#34;
WHILE (counter &lt; limit + 1)
  Read num
  Set sum to sum + num
  Set counter to counter + 1

// Rest of program
</code></pre></div><p>上述伪代码中的循环结构，使用的叫做 while 版本。旁边括号里的表达式同 IF 后面的一样，判断出的结果只有两种值，判断通过就为真，判断不通过就为假，所以也叫做逻辑表达式或布尔表达式。</p>
<p>上面写到的伪代码全都是说明伪代码功能的例子，下面我们来写一个简单的伪代码算法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">Set sum to 0
Read num1
Set sum to sum + num1
Read num2
Set sum to sum + num2
Read num3
Set sum to sum + sum3

IF (sum &lt; 0)
  Print &#34;Error&#34;
ELSE
  Print sum
</code></pre></div><h2 id="程序测试">程序测试</h2>
<p>我们测试程序的方法很简单，即执行程序，看它是否生成了预期的结果。但是，测试远不止运行一次程序这么简单。让我们利用上一个程序详细地分析一下测试。</p>
<p>这个程序将读入三个数字，然后输出它们的和。</p>
<p>那么，如何测试一个特定的程序以确定它的正确性呢？我们将设计和实现一个测试计划。所谓测试计划，就是一个文档，说明了要全面测试程序需要运行的次数以及运行程序时使用的数据。每套输入的数据值称为测试用例。测试计划还要列出选择这套数据和数据值的原因，以及预期的输出结果。</p>
<p>测试用例一定要慎重选择。有几种测试方法可以作为测试过程的指导：</p>
<ul>
<li>代码覆盖测试法设计的测试用例会确保程序中的每条语句都能被执行到。因为测试者能够看到代码，所以这种方法也叫明箱测试法。</li>
<li>数据覆盖测试法是另一种测试方法，它设计的测试用例会确保包括允许使用的数据的边界值。由于这种方法是基于输入的数据，而不是基于代码，所以它又叫暗箱测试法。</li>
</ul>
<p>通常情况下，需要结合这两种方法进行测试。测试计划实现要运行测试计划中列出的所有测试用例，并记录运行结果。如果结果与预期不符，则必须重新审查设计，找出并纠正程序中的错误。</p>
<p>当每种测试用例都输出了预期的结果时，这个过程将结束。注意，实现测试计划让我们对程序的正确性有了信心，但可以确定的指示程序对测试用例能够正确地运行。因此，测试用例的质量尤为重要。</p>
<p>在读入三个数字并对它们求和这个程序中，明箱测试法只包括三个数值，这个程序没有测试候选数据的条件语句。但是，仅仅使用明箱测试法是不够的，因为我们需要尝试正数和负数。读入的数字将存储在一个字中。虽然在问题中没有把数值的范围限制在 -32767 到 +32767 之间，但是实现时却需要注意这样的限制。在测试计划中，我们应该尝试边界值。</p>
<table>
<thead>
<tr>
<th style="text-align:left">测试用例</th>
<th style="text-align:left">输入值</th>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
<th style="text-align:left">预期的输出</th>
<th style="text-align:left">输出值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">输入三个正数</td>
<td style="text-align:left">4</td>
<td style="text-align:left">6</td>
<td style="text-align:left">1</td>
<td style="text-align:left">11</td>
<td style="text-align:left">11</td>
</tr>
<tr>
<td style="text-align:left">输入三个负数</td>
<td style="text-align:left">-4</td>
<td style="text-align:left">-6</td>
<td style="text-align:left">-1</td>
<td style="text-align:left">-11</td>
<td style="text-align:left">-11</td>
</tr>
<tr>
<td style="text-align:left">输入正负混合的数</td>
<td style="text-align:left">4</td>
<td style="text-align:left">6</td>
<td style="text-align:left">-1</td>
<td style="text-align:left">9</td>
<td style="text-align:left">9</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">4</td>
<td style="text-align:left">-6</td>
<td style="text-align:left">1</td>
<td style="text-align:left">-1</td>
<td style="text-align:left">-1</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">-4</td>
<td style="text-align:left">6</td>
<td style="text-align:left">1</td>
<td style="text-align:left">3</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left">输入大数</td>
<td style="text-align:left">32767</td>
<td style="text-align:left">1</td>
<td style="text-align:left">-1</td>
<td style="text-align:left">32767</td>
<td style="text-align:left">32767</td>
</tr>
</tbody>
</table>
<p>要实现这个测试计划，需要运行程序 6 次，每次采用一套测试用例。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>[1] 黛尔，路易斯[美]. 计算机科学概论（第五版）[M]. 北京：机械工业出版社，2016</li>
</ul>
              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">标签</span><br/>
                    
  <a class="tag tag--primary tag--small" href="https://marselau.cc/tags/engineer/">engineer</a>

                  </div>
                
              
            
            <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://marselau.cc/2021/04/00-template-05-todoplan-tables/" data-tooltip="计算机科学与技术学科自学指南（持续更新）">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://marselau.cc/2021/02/01-engineer-03-hardware-systems/" data-tooltip="计算机学科之硬件系统">
              
                  <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

            
              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2021 <a href="https://github.com/marselau">Marse Lau</a>. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="1">
        <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://marselau.cc/2021/04/00-template-05-todoplan-tables/" data-tooltip="计算机科学与技术学科自学指南（持续更新）">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://marselau.cc/2021/02/01-engineer-03-hardware-systems/" data-tooltip="计算机学科之硬件系统">
              
                  <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="1">
  <i id="btn-close-shareoptions" class="fa fa-close"></i>
  <ul class="share-options">
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="https://user-images.githubusercontent.com/87215174/125153235-ee026880-e184-11eb-8424-5a1e843fc25c.gif" alt="作者的图片" />
    
    <h4 id="about-card-name">Marse Lau</h4>
    
      <div id="about-card-bio">The more sent my love for you, the more that I look down upon me.</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        Software Engineer
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        Chongqing, China
      </div>
    
  </div>
</div>

    

    
  
    <div id="cover" style="background-image:url('https://user-images.githubusercontent.com/87215174/125153301-581b0d80-e185-11eb-9975-5dc5ea8bf158.png');"></div>
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js" integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin="anonymous"></script>


<script src="https://marselau.cc/js/script-pcw6v3xilnxydl1vddzazdverrnn9ctynvnxgwho987mfyqkuylcb1nlt.min.js"></script>


<script lang="javascript">
window.onload = updateMinWidth;
window.onresize = updateMinWidth;
document.getElementById("sidebar").addEventListener("transitionend", updateMinWidth);
function updateMinWidth() {
  var sidebar = document.getElementById("sidebar");
  var main = document.getElementById("main");
  main.style.minWidth = "";
  var w1 = getComputedStyle(main).getPropertyValue("min-width");
  var w2 = getComputedStyle(sidebar).getPropertyValue("width");
  var w3 = getComputedStyle(sidebar).getPropertyValue("left");
  main.style.minWidth = `calc(${w1} - ${w2} - ${w3})`;
}
</script>

<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>


  
    
  




    
  </body>
</html>

